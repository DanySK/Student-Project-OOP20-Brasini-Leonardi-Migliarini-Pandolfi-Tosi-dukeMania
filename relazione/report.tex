\documentclass[a4paper,12pt]{report}
\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{setspace}
\usepackage{wrapfig}
\usepackage{xcolor}





% Questo commentalo se vuoi scrivere in inglese.
\usepackage[italian]{babel}

\usepackage[italian]{cleveref}


\newcommand\pathgenerale{img/generali/}
\newcommand\pathsofia{img/sofia/}
\newcommand\pathlaura{img/laura/}
\newcommand\pathgianluca{img/gianluca/}
\newcommand\pathalessandro{img/alessandro/}
\newcommand\pathserafino{img/serafino/}
\newcommand\pathguida{img/guidautente/}

\title{Relazione:\break``DUKEMANIA''}

\author{Gianluca Migliarini, \\ Serafino Pandolfini,\\ Sofia Tosi,\\ Laura Leonardi, \\ Alessandro Brasini}
\date{25 Agosto 2021}

 
\begin{document}

\maketitle
\tableofcontents




\chapter{Analisi}
\section{Requisiti}
Il gruppo si pone come obbiettivo quello di realizzare un clone del videogioco musicale "BeatManiaIIDX".
Lo sviluppo mira alla completa funzionalità a livello di gameplay, e, in aggiunta all'opera originale
dalla quale viene presa ispirazione, offrire all'utente la possibilità di importare i propri livelli giocabili tramite file Midi (Musical Instrument Digital Interface). Viene inoltre considerato come requisito la sostituzione della riproduzione di una traccia audio con la sintesi sonora in tempo reale.
\subsubsection{Requisiti funzionali}
\begin{itemize}
	\item L'utente è in grado di scegliere quale canzone giocare a partire dalla scelta di un file Midi.
	\item L'applicativo deve riprodurre fedelmente tutte le tracce componenti la canzone, con un timbro musicale
	simile a quello di un GameBoy.
	\item L'applicativo deve offrire un gameplay su varie colonne, il giocatore dovrà premere le note sulla rispettiva colonna a ritmo di musica per ottenere punti.
	\item L'applicativo deve memorizzare una scoreboard con tutti i punteggi delle varie partite relative alla canzone selezionata.
	\item La traccia giocabile viene scelta dall'utente dalla lista delle tracce componenti la canzone.
	\item L'applicativo deve "semplificare" le traccie musicali complesse rendendole giocabili, segnalando un grado di difficoltà
\end{itemize}

\subsubsection{Requisiti non funzionali}
\begin{itemize}
	\item L'applicativo deve funzionare correttamente sia su Windows sia su sistemi basati su Unix
	\item La fluidità del gameplay e la qualità dell'audio non devono essere compromesse dalla pesantezza del file midi (ovviamente se non troppo complesso)
\end{itemize}
\newpage

% section analisi di modello e dominio
\section{Analisi e modello del dominio}


Dukemania dovrà essere in grado di fare selezionare all'utente il proprio nickname e una canzone in formato Midi. Dovrà inoltre permettere la configurazione dei nomi di tracce e strumenti associati alla canzone selezionata. Inoltre, la traccia da giocare, sara' anch'essa selezionabile dall'utente.
I vari strumenti saranno caricati a partire da un file di configurazione in locale all'avvio del gioco e saranno detti sintetizzatori.
Ci sarà una entità responsabile della gestione e riproduzione del tono e del volume in entrata e in uscita. Le tracce della canzone, con le relative note, verranno individuate da un parser. A ogni traccia verrà associato un solo sintetizzatore che riprodurrà uno strumento.
Il gameplay si svolgerà su varie colonne, in ognuna delle quali cadranno note relative alla traccia selezionata, opportunamente semplificata per garantirne la giocabilità.
Le difficoltà primarie riguarderanno il calcolo del punteggio in base alla precisione del giocatore e la sincronizzazione tra la caduta delle note e il suono riprodotto.
Alla fine della partita, dovrà essere visualizzata una schermata contenente il punteggio migliore di ogni singolo giocatore ottenuto sulla canzone selezionata in precedenza.
\begin{figure}[!htb]
	\centerline{\includegraphics[scale=0.7]{\pathgenerale uml_analisi.jpg}}
	\caption{Schema UML della fase di analisi.}
	\label{img:analysis}
\end{figure}
\newpage


\chapter{Design}
\section{Architettura}
L'architettura di DukeMania è basata sul pattern MVC.
La classe DukeMania è l'entry point dell'applicazione, al suo interno vengono inizializzate tutte le View e il WindowManager, la classe che fungerà da Controller principale.
Il compito pricipale di WindowManager è quello di cambiare, tra le varie View, la finestra da renderizzare e visualizzare, occupandosi inoltre di passare il Model alle varie schermate, che a loro volta lo passeranno al relativo Controller.
Il Model principale, rappresentato da GameModel, conterrà le configurazioni di gioco, rendendole così accessibili a tutte le View.
La classe WindowManager implementa l'interfaccia SwitchWindowNotifier, il cui compito principale e' quello di notificare il WindowManager, segnalandogli che un controller di una View vuole sostituire la finestra attiva.
Tutte le View implementano l'interfaccia Window, la quale le rende predisposte a ricevere i dati del Model, e ad utilizzare lo SwitchWindowNotifier tramite il proprio controller.
Utilizzando questa strategia è semplice aggiungere nuove View e definirne il comportamento.
Un sistema di window-switching è già implementato in LibGDX ma, al fine di rendere il più riutilizzabile possibile e platform-indipendent 
questa meccanica, è stato deciso di implementare una versione generale che può essere applicata a qualsiasi tipo di libreria grafica.
\begin{figure}[!htb]
	\centerline{\includegraphics[scale=0.7]{\pathgenerale architettura.png}}
	\caption{Schema UML dell'architettura MVC.}
	\label{img:architecture}
\end{figure}
\clearpage


\section{Design dettagliato}
\subsection{Gianluca Migliarini}
Nella mia parte di design dettagliato viene descritto il funzionamento del motore audio.
La classe Engine si occupa di aggiornare e valutare lo stato dei vari sintetizzatori (tastiere simulate), ad ogni chiamata del metodo render viene riempito un buffer di samples (campioni audio). Ogni campione audio viene calcolato sommando i campioni audio di tutti i sintetizzatori al momento della chiamata.
Una volta che il buffer e' pieno, viene mandato al dispositivo audio che si occupa di suonare i vari campioni.
Ogni traccia della canzone viene affidata ad un sintetizzatore di tastiera o di percussioni. Per differenziarli, e' stata creata l' interfaccia Synth, contenente i metodi comuni tra i due, per calcolare quante note/percussioni stanno suonando e per ottenere un campione audio.
Le variabili di impostazioni che garantiscono il corretto funzionamento dell'audio sono scritte nella classe Settings.java, come campi finali statici.
Per evitare costi computazionali troppo alti, i vari campioni delle varie note di tutti i sintetizzatori vengono pre-caricati in istanze anonime dell'interfaccia BufferManager. Lo scopo di quest'ultima e' quello di rendere una nota risuonabile in ogni momento tramite il metodo refresh, e, tramite i meotodi di iterator, ottenere il prossimo campione suonabile e controllarne l'esistenza. \\ \\
I sintetizzatori di tastiera e di percussioni si differenziano nel seguente modo:
\newpage
\subsubsection{KeyboardSynth}
Per i vari sintetizzatori di tastiere, oltre ai metodi dell'interaccia Synth, e' presente il metodo playTimeNote, per suonare una nota ad una determinata frequenza per un determinato tempo espresso in microsecondi. \\
Per aumentare le performance, i vari campioni delle note sono caricati all'instanziamento della classe, a partire da una lista contenente gli indici delle note utilizzate e il relativo tempo di suonata. \\
I BufferManager vengono creati a partire da una classe Enveloper, che si occupa di gestire il volume della nota in entrata e in uscita.
Per impostare correttamente tutti i parametri dei sintetizzatori di tastiera ho deciso di utilizzare il pattern "builder", in quanto alcune impostazioni non sono sempre necessarie, ad esempio gli LFO, visti in dettaglio piu' avanti. \\ \\ \\
\begin{figure}[!htb]
	\centerline{\includegraphics[scale=0.7]{\pathgianluca synth_builder}}
	\caption{Schema UML del Builder dei sintetizzatori di tastiere.}
	\label{img:SynthBuilder}
\end{figure}
\clearpage
\subsubsection{DrumSynth}
Nel caso del sintetizzatore per le percussioni, le varie istanze di BufferManager sono presenti come campo read only dell'enum DrumSamples. Ho scelto di utilizzare questo enum come pattern "singleton" in quanto non richiede l' istanziazione di oggetto, e perchè le percussioni non cambiano tra i diversi file Midi, a differenza delle note le quali hanno lunghezze diverse.
L'unico metodo esterno all'interfaccia Synth e' playPercussion, il quale si occupa di ri-iniziare la riproduzione di un elemento della batteria. \\
Per aggiungere nuove percussioni, in futuro, basterà aggiungere un nuovo valore all'enum e caricare il relativo BufferManager, questo verrà assegnato automaticamente alle percussioni Midi idonee.
\\ \\ \\
\begin{figure}[!htb]
	\centerline{\includegraphics[scale=0.7]{\pathgianluca drum_singleton}}
	\caption{Schema UML del Singleton Drum Samples.}
	\label{img:drumSingleton}
\end{figure}
\clearpage
\subsubsection{Creazione delle note e timbri sonori}
Durante il caricamento, i sintetizzatori utilizzano l'enum Wavetables, contenente le varie forme audio utilizzabili assumibili dalle note; queste forme sono caricate all'avvio in array, i quali possono essere letti in intervalli più o meno distaccati per simulare le varie frequenze.
Per differenziare i timbri sonori faccio uso degli LFO, funzioni adibite al cambio del tono e del volume nel tempo. Ho deciso di utilizzare il pattern "static factory" a causa della necessità di essere utilizzata senza istanze.
Per aggiungere funzioni LFO in futuro, e avere ancora più varietà del suono,
SynthBuilder utilizza una strategy con "Function Long,Float" come interfaccia funzionale, la funzione che rappresenta l'LFO. 
\\ \\
\begin{figure}[!htb]
	\centerline{\includegraphics[scale=0.7]{\pathgianluca wavetables}}
	\caption{Schema UML dell'interazione tra LFOFactory, keyboardSynth e Wavetable.}
	\label{img:wavetables}
\end{figure}
\clearpage
\subsection{Serafino Pandolfini}
progetto 
\newpage
\subsection{Sofia Tosi}
Questo paragrafo illustra il design relativo alla gestione dell'input e degli assets.
In seguito ad un'attenta valutazione, si è deciso di far interfacciare l'utente all'applicazione DukeMania tramite l'utilizzo di
una tastiera per pc. 
Durante la progettazione della sezione concernente l'input, ho ritenuto oppurtuno utilizzare il pattern Adapter.
La classe EventsFromKeyboardImpl rappresenta l'Adapter in sè che, implementando l'interfaccia omonima, riesce a semplificare e a permettere l'interazione
tra la tastiera, che sfrutta la libreria com.badlogic.gdx.Input, e la classe relativa alla grafica PlayScreen.
Per non superare eccessivamente l'ammontare di ore, l'applicazione attuale è stata implementata per consentire solo l'utilizzo della tastiera del pc. 
Laddove si volesse, in futuro, cambiare la periferica, l'applicazione non esclude questa possibilità. Si potrebbe infatti implementare EventsFromKeyboard 
e sostituire la classe dell'adapter con un altro adapter che interagisca con una diversa periferica (ad esempio un gamepad, una SG Guitar Hero o una tastiera midi).
\newline
\begin{figure}[!htb]
	\centerline{\includegraphics[scale=0.7]{\pathsofia sofia_adapter.jpg}}
	\caption{Schema UML dell'Adapter.}
	\label{img:adapter}
\end{figure}
\clearpage \hfill\break
Un'altra peculiare classe che merita di essere citata è l'AssetsManager che, come dice il nome, si dedica all'organizzazione degli assets, ovvero tutte le risorse grafiche
necessarie per il corretto funzionamento dell'applicazione. Queste risorse, che possono essere, ad esempio, le texture degli elementi nella GUI o i file con i font utilizzati,
vengono caricate una sola volta in memoria.
Ho deciso di sfruttare il pattern Singleton per la realizzazione di tale classe. Difatti è importante che ci sia una sola istanza dell'AssetsManager per evitare che le risorse 
grafiche vengano istanziate più volte in memoria sprecando spazio inutilmente. 
\newline
\begin{figure}[!htb]
	\centerline{\includegraphics[scale=0.7]{\pathsofia sofia_singleton.png}}
	\caption{Schema UML del Singleton.}
	\label{img:singleton}
\end{figure}
\clearpage \hfill\break
\subsection{Laura Leonardi}
Per quanto riguarda il parsing dei file midi è stata realizzata la classe MidiParser che ha lo scopo di ottenere, a partire da un file .mid, un oggetto di classe Song contenente una serie di informazioni utili per sintesi audio e la generazione delle tracce di gioco. Dalla classe Song saranno infatti ottenibili delle tracce (ParsedTrack), una per strumento più quella dedicata alle percussioni, da cui saranno a loro volta ottenibili le AbstractNotes, ovvero le note che le compongono. La classe MidiParser è stata dotata di un'interfaccia Parser per permettere un futura implementazione di un nuovo parser a partire da un tipo di file differente dal midi.

\subsubsection{Abstract Factory}

\begingroup
\fontsize{10pt}{12pt}\selectfont
Le tracce e le note possono essere di due tipologie: normali e percussioni. Per semplificare la costruzione di questi diversi tipi di tracce e note ho pensato di utilizzare il pattern abstract factory, che permette la creazione di famiglie di oggetti della stessa tipologia. Sebbene infatti i campi e i metodi richiamabili dai differenti tipi di tracce e note coincidano solo in parte, ho ritenuto utile l'implementazione di questo pattern per separare la costruzione di queste tipologie di oggetti dal resto del codice, facilitandone così la lettura e l'utilizzo e portando la complessità di questa distinzione fuori dal MidiParser. Nello specifico questo pattern è stato realizzato tramite l'interfaccia AbstractFactory, che viene implementata dalle Concrete Factory PercussionFactoryImpl e FactoryImpl, che a loro volta si occuperanno di creare prodotti, quali PercussionNote o Note (che estendono la classe astratta AbstractNote, contenente i metodi in comune), e PercussionTrack o KeyboardTrack(che estendono la classe astratta ParsedTrack, contenente i metodi in comune). La scelta di utilizzare classi astratte invece di interfacce è stata effettuata per ottimizzare quanto più possibile il riuso del codice, in partcolare le parti riguardanti i campi privati in comune, mantenendo comunque il vincolo della non istanziabiltà dei prodotti dell'abstract factory. Inoltre nonstante la classe PercussionTrack non aggiunga nulla alla classe astratta ParsedTrack si è compiuta questa scelta implementativa per favorire una futura estensione della classe PercussionTrack o una proliferazione di altri tipi di track, cosa che sarebbe resa più difficile dalla sostituzione dell'abstract class ParsedTrack con la classe PercussionTrack. Per quanto riguarda la selezione della factory corretta è stata implementata un'utility class FactoryConfigurator che ritorna la concrete factory corretta a partire dal canale midi.
\endgroup
\newpage





\begin{figure}[!htb]
	\centerline{\includegraphics[scale=0.38]{\pathlaura umlfactory.jpg}}
	\caption{Schema UML della Factory.}
	\label{img:midifactory}
\end{figure}
\hfill\break\break\break\break\break\break

\subsubsection{Singleton}
Nell'implementare le concrete factory ho ritenuto opportuno che non si generassero, per ogni creazione di nota o traccia, nuove istanze di factory, di conseguenza ho applicato il pattern Singleton alle classi PercussionFactoryImpl e FactoryImpl. Il pattern singleton è stato utilizzato anche nella classe MidiParser poiché è sufficiente una sola sua istanza per il corretto funzionamento del programma.
\newpage

\begin{figure}[!htb]
	\centerline{\includegraphics[scale=0.8]{\pathlaura midiparser.jpg}}
	\caption{TODO.}
	\label{img:midiparser}
\end{figure}  
\hfill\break\break
\begin{figure}[!htb]
	\centerline{\includegraphics[scale=0.8]{\pathlaura percfactimpl.jpg}}
	\caption{TODO.}
	\label{img:percfactimpl}
\end{figure}
\hfill\break\break
\begin{figure}[!htb]
	\centerline{\includegraphics[scale=0.8]{\pathlaura factimpl.jpg}}
	\caption{TODO.}
	\label{img:factimpl}
\end{figure}
\clearpage

\subsection{membro 5}
progetto 
\newpage



\chapter{Sviluppo}
\section{Testing}
Abbiamo deciso di eseguire test automatizzati prevalentemente per le classi più complesse. Per quanto riguarda le varie schermate e la gestione di queste, una volta prese in considerazione le limitazioni causate da libGdx, abbiamo preferito eseguire accurati test manuali. \\ \\ Per il testing del file midi sono stati utilizzati anche dei test manuali, specialmente nella fase iniziale, con lo scopo di comprendere appieno e con quanta più precisone possibile la struttura del file midi \\
{\setstretch{0.6}
\begin{itemize}
	\item \textbf{testStraightLFO - testSquareLFO - testSineLFO - testIntervalLFO:} per ogni funzione LFO è presente un test per garantirne il corretto funzionamento.	
	\item \textbf{TestKeyboardSynth:} testato la correttezza del conto di quante note stanno suonando al momento, il metodo per ottenere il campione audio, il metodo per risuonare una nota.	
	\item \textbf{DrumSynthTest:} testato la correttezza del conto di quante percussioni stanno suonando al momento, il metodo per ottenere il campione audio, il metodo per risuonare una percussione.	
	\item \textbf{TestBuilder:} testate le eccezioni e il corretto funzionamento di metodo per ritornare l'istanza di KeyboardSynth.
	\item \textbf{TrackFilter:} testate singole tracce con numeri diversi di note e liste di tracce richiedenti filtraggi differenti.	
	\item \textbf{GameUtilities:} testata l'attribuzione delle difficoltà alle tracce.	
	\item \textbf{ColumnLogic - noteQueuing:} testate diverse configurazioni di numero di note, sia sovrapposte che non, e colonne.	
	\item \textbf{ColumnLogic - verifyNote:} testato il calcolo del punteggio in relazione a precisione della nota e combo di note.
	\item \textbf{testMidiParser:} testata la correttezza della song restituita e degli elementi che la compongono.
\end{itemize}
}
\newpage
\section{Metodologia di lavoro}
\subsection{Gestione del lavoro}
Lo sviluppo del progetto è stato preceduto da una fase preliminare di analisi, durante la quale tutti insieme abbiamo lavorato per definire le basi dell'applicazione e, successivamente, per specificare i vari dettagli implementativi tramite UML.
La suddivisione delle parti del progetto è avvenuta in modo equo assegnando a ciascuno una parte significativa e importante del progetto.
\subsection*{Gestione del DVCS}
Per il DVCS è stato utilizzato git, in quanto è stato il Software spiegato a lezione. Abbiamo creato una repository su github e abbiamo deciso di creare un branch per ogni membro del team. In seguito, quando ritenuto che ognuno di noi avesse implementato il "core" della propria parte, abbiamo deciso di eseguire un merge in un nuovo branch "alpha", sul quale ogni membro ha continuato a salvare le proprie modifiche e sul quale sono stati effettuati i primi test di giocabilità.
\newpage

\subsection*{Suddivisione del lavoro}
\subsection{Gianluca Migliarini}

In questo progetto, mi sono dedicato principalmente della riproduzione audio.
Gli oggetti principali del mio package sono i Synth, i quali sono in grado, alla chiamata di un metodo, di restituire un campione audio ottenuto dalla somma di tutte le note o percussioni che stanno suonando simultaneamente.
La classe Engine, si occupa di ottenere i campioni dai vari sintetizzatori, comporre il buffer audio, regolarne il volume e riprodurlo in uscita.
Mi sono inoltre dedicato allo sviluppo di delle classi LFOFactory ed Enveloper, per, rispettivamente aggiungere varietà ai timbri sonori e per regolare il volume delle singole note in entrata e in uscita al fine di eliminare i "click" audio, sgradevoli all'udito.
Infine, per semplificare la gestione delle forme audio da caricare nelle note, ho sviluppato l'enum read-only WaveTable. \\ \\
Classi sviluppate singolarmente:
{\setstretch{0.6}
	\begin{itemize}
		\item DrumSynth
		\item Engine
		\item Enveloper
		\item Filters
		\item KeyboardSynth
		\item LFOFactory
		\item Settings
		\item SynthBuilder
	\end{itemize}
} 
\hfill\break
Inoltre, a mio parere, anche gli enum WaveTable DrumSamples devono essere listati, inquanto contenti metodi e campi oltre alla semplice enumerazione.
\textbf{• Problematiche riscontrate}\hfill\break
problemi 
\newpage

\subsection{Serafino Pandolfini}
Per questo progetto mi sono focalizzato principalmente sugli aspetti di logica del gioco, comprendenti la gestione di tracce e note e della precisione, sia nell'aspetto audio-video che nel calcolo dei punteggi di gioco. Per quanto concerne l'aspetto delle tracce la classe fondamentale da me implementata è TrackFilterImpl che, fornita in input una Song, ottenuta dal midiParser, riduce il numero di note presenti in ogni sua traccia in modo da renderle giocabili. Ho provato diverse strategie per ridurre il numero delle note in modo da ottenere tracce con una distribuzione di note uniforme nel tempo e con quantitativi di note quanto più possibile differente per fornire più scelta al giocatore. Questa classe è stata particolarmente facile da integrare in quanto si occupa di elaborare dati già esistenti e a restituirli come era stato previsto in fase di progettazione. Per le note e il calcolo del punteggio ho realizzato un unica classe principale ColumnLogicImpl che divide le note nelle varie colonne grafiche eliminando le eventuali collisioni e, utilizzando la classe secondaria NoteRange, permette di fornire un punteggio per ogni nota premuta durante il gioco sulla base della configurazione del calcolo scelta tra le classi di calcolo del punteggio. Anche in questo caso l'obiettivo è stato quello di ottenere una distribuzione uniforme tra le varie colonne delle note e di fornire un attribuzione del punteggio che considerasse eventuali imprecisioni sulla pressione delle note durante il gioco. Questa classe è stata particolarmente difficile da finalizzare per una divergenza di classi/interfacce tra la parte logica e grafica, ed è stato quindi necessario creare una classe intermediaria LogicNoteImpl e dei metodi aggiuntivi in grado di fornire i dati mancanti per permettere un integrazione tra le due parti.  
In merito agli aspetti di precisione audio-video ho sviluppato la classe PlayerAudio che suona le note in base al tempo trascorso dall'inizio della traccia, ottimizzando la latenza tra ciò che appare a schermo e l'audio di gioco creando una relazione tra l'aspetto grafico e quello audio.
L'integrazione di questa classe non ha generato particolari problemi se non la necessità di avere una conoscenza superficiale del funzionamento delle altre classi presenti nell'audioengine.
L'ultima parte sviluppata singolarmente è quella relativa alla classe GameUtilitiesImpl, utilizzata per attribuire a ogni traccia restituita dal trackFilter una difficoltà basata sul numero di note.
 \\ \\
Classi sviluppate singolarmente:
{\setstretch{0.6}
	\begin{itemize}
		\item classe 1
		\item classe 1
		\item classe 1
	\end{itemize}
}
\hfill\break
\textbf{• Problematiche riscontrate}\hfill\break
problemi 
\newpage

\subsection{Sofia Tosi}
In questa sezione si parlerà di grafica. La classe principale è PlayScreen, il cuore della View relativa al game, attraverso la
quale vengono richiamate tutte le altre classi implementate dalla sottoscritta e alcune classi dei miei compagni. 
Questa classe, alla quale ho dedicato più tempo, mi ha messo alla prova e mi ha stimolato a voler conoscere cose nuove. Infatti per implementarla
mi sono servita della libreria grafica Libgdx, con la quale non avevo mai lavorato. Un'idea che mi è balenata in mente mentre la implementavo, che non si è 
manifestata durante l'analisi svolta all'inizio del progetto, è quella di creare una classe a parte, EventsFromKeyboardImpl, 
per gestire i comandi di input. EventsFromKeyboardImpl, come vuole suggerire il nome, è stata pensata per essere compatibile con una tastiera per pc. 
Nulla vieta di avvalersi di un'altra periferica. Infatti, ho cercato di limitare al massimo le dipendenze in PlayScreen in modo tale che risulti semplice sostituirla, 
avendo a disposizione un'altra classe compatibile con un'altra periferica.
Ho ritenuto opportuno implementare AssetsManager per gestire le risorse grafiche. Questa classe permette di caricare in memoria tutte gli asset grafici in una
sola volta. Sarà poi il compito di PlayScreen richiamarli singolarmente, al momento opportuno, e mostrarli a video.
Tra i miei compagni del gruppo, quello con cui ho dovuto interagire di più è Serafino Pandolfini, ed è stato proprio da quest'interazione che è scaturita la classe
KeyImpl. Lo scopo di KeyImpl è proprio quello di fornirgli dei metodi per poter ottenere il tempo di inizio e di fine nel quale l'utente preme un tasto.
Una classe fondamentale da utilizzare in PlayScreen è GraphicNoteImpl. GraphicNoteImpl rappresenta la nota dal punto di vista grafico. In questa classe sono presenti i metodi per disegnare la nota, per disegnare le scintille che compaiono sulla nota quando l'utente la
preme al momento giusto. Nonostante sia una classe che implementa metodi legati alla grafica si è cercato di limitare l'uso di libgdx, per ridurre il più
possibile le dipendenze. Un'ultima classe che merita di essere citata è senza dubbio SizeImpl, la quale adatta la GUI alla dimensione dello schermo del pc sul quale viene 
lanciata l'applicazione.
Per collaborare io e i miei compagni abbiamo deciso di stabilire insieme come dovevano essere strutturate le interfacce e, successivamente, abbiamo implementato il codice basandoci sulle decisioni prese. Nonostante ciò, sono sorte delle problematiche che abbiamo dovuto risolvere insieme in un secondo momento (ad esempio, la lunghezza del suono di ogni nota non corrispondeva all'altezza della texture mostrata a video).  
\\ \\
Classi sviluppate singolarmente:
{\setstretch{0.6}
	\begin{itemize}
		\item PlayScreen
		\item AssetsManager
		\item EventsFromKeyboardImpl
		\item GraphicNoteImpl
		\item SizeImpl
		\item KeyImpl
		\item ComputingShiftImpl
	\end{itemize}
}
\hfill\break

\subsection{membro 4}
Studio del protocollo midi e midi parsing, creazione delle tracce e delle note che le compongono, gestione degli strumenti  \\ \\
Classi sviluppate singolarmente:
{\setstretch{0.6}
	\begin{itemize}
		\item AbstractFactory
		\item AbstractNote
		\item FactoryConfigurator
		\item FactoryImpl
		\item Instrument
		\item InstrumentType
		\item InvalidNoteException
		\item MainTemp
		\item MidiParser
		\item MidiParserImpl
		\item MidiTrack
		\item Note
		\item Percussion
		\item PercussionFactoryImpl
		\item PercussionNote
		\item PercussionTrackImpl
		\item Song
		\item TestMidiParser
		\item TrackImpl
	\end{itemize}
}
\hfill\break
\textbf{• Problematiche riscontrate}\hfill\break
problemi 
\newpage

\subsection{membro 5}
ha fatto questo bla bla bla \\ \\
Classi sviluppate singolarmente:
{\setstretch{0.6}
	\begin{itemize}
		\item classe 1
		\item classe 1
		\item classe 1
	\end{itemize}
}
\hfill\break
\textbf{• Problematiche riscontrate}\hfill\break
problemi 
\newpage



\section{Note di sviluppo}
schermata
\newpage

\subsection{Gianluca Migliarini}
Feature avanzate del linguaggio:
\begin{itemize}
	\item \textbf{lambda:} usate per caricare gli iteratori delle note per ogni traccia e i buffer dei campioni audio nei sintetizzatori di tastiere.
	\item \textbf{stream:} usati per controllare lo stato di tutti i sintetizzatori e sommare i vari campioni di questi ultimi.
	\item \textbf{optional:} usati per i campi opzionali nel builder dei sintetizzatori di tastiera. 
	\item \textbf{function:} usate per gestire gli LFO
\end{itemize}
Librerie utilizzate:
\begin{itemize}
	\item \textbf{libgdx:} utilizzata per Gdx.audio.newAudioDevice, necessario per riprodurre sul dispositivo audio hardware il buffer di campioni.
\end{itemize}
Classi riutilizzate: \\
Per comodità ho deciso di riutilizzare la classe generica Pair, introdotta dal prof. Viroli durante il corso.
\newpage

\subsection{membro 2}
commenti
\begin{itemize}
	\item \textbf{lambda:} tanta roba
	\item \textbf{stream:} tanta roba
\end{itemize}
librerie utilizzate:
\begin{itemize}
	\item \textbf{libgdx:} gestione grafica
\end{itemize}
\newpage

\subsection{Sofia Tosi}
Feature avanzate del linguaggio:
\begin{itemize}
	\item \textbf{lambda:} usate nella dispose dell'AssetsManager per rilasciare ogni singola risorsa utilizzata.
	\item \textbf{stream:} usato nel metodo associationKeyColumn per associare in maniera efficiente ogni colonna al relativo tasto della tastiera e nel PlayScreen per calcolarmi la lista con le note che stanno suonando al momento.
	\item \textbf{interfacce funzionali:} usate per eliminare le note che hanno terminato di suonare.
	\item \textbf{Optional:} usati nella classe GraphicNoteImpl.
\end{itemize}
librerie utilizzate:
\begin{itemize}
	\item \textbf{libgdx:} libreria grafica Libgdx: studio autonomo di tale libreria per realizzare l'interfaccia di gioco.
\end{itemize}
Classi riutilizzate: \\
Utilizzo della classe Pair fornita gentilmente dal professore Viroli
\newpage

\newpage

\subsection{Laura Leonardi}
Feature avanzate del linguaggio:
\begin{itemize}
	\item \textbf{lambda:} usate negli stream
	\item \textbf{stream:} utilizzati per l'aggiunta e la gestione delle note, per il riempimento di una mappa che associa note a durata massima, per l'associazione tra strumento e sintetizzatore e per l'associazione di percussioni ai relativi DrumSamples e per ottenere tracce correttamente nella classe di testing.
	\item \textbf{optional:} usati per l'inserimento di note "parziali" in attesa della loro conclusione dettata dal midi.
\end{itemize}
librerie utilizzate:
\begin{itemize}
	\item \textbf{javax.sound.midi:} gestione file .mid
\end{itemize}
Classi riutilizzate: \\
Classe generica Pair, fornita dal prof. Viroli.
\newpage

\subsection{membro 5}
commenti
\begin{itemize}
	\item \textbf{lambda:} tanta roba
	\item \textbf{stream:} tanta roba
\end{itemize}
librerie utilizzate:
\begin{itemize}
	\item \textbf{libgdx:} gestione grafica
\end{itemize}
\newpage




\chapter{Commenti Finali}
\section{Autovalutazione e lavori futuri} 
schermata 
\newpage

\section{Gianluca Migliarini}
\subsection{commenti}
Sono molto soddisfatto del gruppo e del lavoro che siamo riusciti a portare a termine.
Essendo una delle mie prime esperienze di lavoro in team ho trovato delle difficoltà principalmente riguardanti
la gestione del tempo e a volte la coordinazione con gli altri membri, per questo ringrazio i miei compagni per la disponibilità e per aver tenuto sempre un clima sereno durante lo sviluppo; ritengo quindi che questo progetto mi abbia permesso di crescere notevolmente dal punto di vista organizzativo, in particolare per l'utilizzo di un software per la gestione del versioning.
Inoltre sono molto felice di essere riuscito ad inserire in un progetto concreto il mio interesse per la sintesi audio.
\subsection{difficoltà riscontrate}
In conclusione, ritengo che il corso sia stato più che sufficiente per garantirmi uno sviluppo del progetto senza problematiche troppo grandi a livello implementativo, e che mi abbia incentivato ad utilizzare gli aspetto più avanzati del linguaggio, i quali avrei probabilmente evitato.
\newpage
\section{Serafino Pandolfini}
\subsection{commenti}
Sono personalmente soddisfatto del lavoro che ho svolto; fin dai miei primi approcci alla programmazione ho sempre preferito, piuttosto che dedicarmi a particolari funzionalità di librerie, a porre il mio interesse sulle strutture dati e le loro organizzazioni e in questo progetto ho avuto modo di mettermi alla prova in un contesto che non fosse il mio solito programma giocattolo scoprendo le mie effettive conoscenze e capacità. Ho avuto modo di apprezzare in particolare gli stream e le loro funzionalità che riuscivano sempre a stupirmi. È stata ricorrente la situazione in cui emergeva un problema ed esisteva già un operazione in grado di risolverlo in modo quasi istantaneo.
Non ho intenzione di continuare a sviluppare questo progetto ma se non mi fossi limitato al monte ore richiesto mi sarebbe piaciuto sviluppare altre modalità di gioco con calcoli dei punteggi e gameplay differenti prendendo ispirazione da altri giochi simili. 
\subsection{difficoltà riscontrate}
Il progetto non è stato esente da difficoltà, principalmente la coordinazione tra i vari membri per quanto ottimale ha portato a incomprensioni sul funzionamento di certi aspetti e talvolta si è dovuto ricorrere a soluzioni non ottimali dal mio punto di vista. Dal mio punto di vista però l'emergere di queste difficoltà mi ha permesso di avere una comprensione più completa del progetto che non avrei avuto altrimenti.
\newpage
\section{Sofia Tosi}
\subsection{commenti}
DukeMania è stato il primo grande progetto a cui ho preso parte. 
Non nego la mia preoccupazione iniziale, poi, pian piano durante l'analisi e implementando codice, è svanita.
Questo progetto mi ha permesso di crescere ampiamente, in vari ambiti.
In primo luogo, ho imparato cosa significa scrivere codice di qualità e quanto siano importanti i pattern.
Al contempo, ho anche aumentato la mia conoscenza studiando una nuova libreria grafica e imparando meglio le potenzialità di Git e LaTex. 
Realizzare DukeMania non è stato affatto facile, soprattutto perchè si tratta di un gioco musicale e le mie conoscenze in quell'ambito
sono esigue. Ma grazie alla collaborazione con i miei compagni, tutti molto disponibili e gentili siamo riusciti nel nostro intento.
Indipendentemente dalla valutazione finale, mi ritengo molto soddisfatta del progetto.
\subsection{difficoltà riscontrate}
Ritengo il corso di Programmazione ad Oggetti un corso molto valido e interessante. 
Mi ha permesso di approfondire nuovi argomenti non soltanto da autodidatta, ma anche con le lezioni dei prof 
che ho trovato chiare e stimolanti. L'unica modifica che apporterei è l'aggiunta di ore di laboratorio per
imparare già da subito ad applicare correttamente i pattern e Csharp. Nella mia modesta opinione avere più ore da dedicare a questi argomenti
comporterebbe un notevole aiuto.
\newpage
\section{Laura Leonardi}
Personalmente ritengo che in questo progetto sia stata effettuata un'ottima collaborazione tra membri del team, ognuno di quali è sempre stato molto disponibile, inoltre sebbene non possedessi molta esperienza col DVCS sono riuscita comunque a farne uso e a comprenderne la comodità. Un altro lato decisamente positivo del progetto è stata la possibilità di approfondire nuovi argomenti, infatti ho trovato molto interessante lavorare e scoprire il funzionamento del protocollo MIDI, del quale prima di questo progetto, non essendo particolarmente appassionata di musica, non conoscevo neppure l'esistenza. Sono in definitiva soddisfatta dell'esito del progetto.
\subsection{difficoltà riscontrate}
Dal mio punto di vista il corso di oop si è rivelato impegnativo ma decisamente utile per quanto riguarda le pratiche di buona programmazione e l'utilizzo di DVCS, nonostante questo ritengo che purtroppo le ore di laboratorio dedicate all'effettiva programmazione siano state un poco ridotte, in particolare per quanto riguarda C\#.
\newpage

\section{Alessandro Brasini}
\subsection{commenti}
Tenendo in conto degli ostacoli incontrati nel corso dello sviluppo del progetto per arrivare a conoscere libgdx, mi sento molto soddisfatto del risultato finale ottenuto.
Sono inoltre riconoscente ai miei compagni di team, i quali hanno mantenuto un approccio serio e professionale, nonostante la nostra comune inesperienza riguardante il lavoro in gruppo.
Ho imparato l'importanza della fase di ideazione del progetto e l'utilità di suddividere equamente, tra compagni, il carico di lavoro, senza mai sottovalutare l'importanza di un DVCS, il quale si è rivelato fondamentale.
In conclusione, la cosa che ho imparato di più da questo progetto, è il programmare in una modalità più responsabile e consapevole, in quanto i miei collaboratori riponevano fiducia nel mio lavoro come io nel loro.
\subsection{difficoltà riscontrate}
Durante il mio percorso formativo avevo già avuto occasione di programmare ad oggetti, ma è stato solamente dopo questo corso che ho capito la vera utilità di concetti come interfacce e classi astratte. Inoltre sono grato di aver utilizzato java, in quanto ho avuto la possibilità di imparare a programmare in un linguaggio del tutto nuovo, e per la prima volta ricco di sfaccettature e funzioni avanzate.
Ritengo infine che le uniche problematiche inerenti al corso siano dovute dalla metodologia di lezione a distanza, problemi che purtroppo si sono riversati durante gli appelli d'esame e che mi hanno impedito di beneficiare degli insegnamenti al massimo.
\newpage

\chapter{Appendice - Guida Utente}
\begin{figure}[!htb]
	\centerline{\includegraphics[scale=0.55]{\pathguida titlescreen2}}
	\caption{La schermata iniziale del gioco.}
	\label{img:title}
\end{figure}
\begin{figure}[!htb]
	\centerline{\includegraphics[scale=0.6]{\pathguida songconfig}}
	\caption{La schermata di configurazione della partita.}
	\label{img:select}
\end{figure}
\begin{figure}[!htb]
	\centerline{\includegraphics[scale=0.3]{\pathguida game}}
	\caption{La schermata di gioco.}
	\label{img:game}
\end{figure}

\end{document}